---
title: Agent Integration
description: Integrate Guardrail-Sim with AI coding assistants and agents.
---

# Agent Integration

Guardrail-Sim is designed to be "agent-friendly"—AI assistants can understand the codebase and use the MCP tools effectively.

## llms.txt Support

We provide `/llms.txt` and `/llms-full.txt` endpoints for AI agent consumption:

- **`/llms.txt`** - Index file with links and descriptions
- **`/llms-full.txt`** - Complete documentation in a single file

These follow the [llms.txt standard](https://llmstxt.org/) for AI-optimized documentation.

## Claude Desktop

### Configuration

Add to your Claude Desktop config (`~/Library/Application Support/Claude/claude_desktop_config.json` on macOS):

```json
{
  "mcpServers": {
    "guardrail-sim": {
      "command": "node",
      "args": ["/path/to/guardrail-sim/packages/mcp-server/dist/index.js"]
    }
  }
}
```

### Usage

Once configured, Claude can:

```
You: "Check if a 15% discount is allowed for an order of 50 units with 40% margin"

Claude: I'll evaluate that discount against the pricing policy.

[Calls evaluate_policy tool]

The 15% discount is rejected. Here's why:
- Volume tier violation: Orders under 100 units are limited to 10% discount
- Your order of 50 units qualifies for the base tier only

Options to get 15% discount:
1. Increase order quantity to 100+ units
2. Request a 10% discount instead (maximum for base tier)
```

## Cursor / VS Code

### Cursor Rules

The repository includes `.cursor/rules/guardrail-sim.mdc` with detailed conventions for Cursor AI:

- TypeScript patterns (imports, exports, types)
- Testing patterns (Node.js test runner)
- Policy engine usage
- MCP server patterns
- Anti-patterns to avoid

### GitHub Copilot

The repository includes `.github/copilot-instructions.md` with:

- Project structure overview
- Code conventions
- Common patterns and examples

## Coding Assistant Context

When working with AI coding assistants, you can reference these files:

```
Read these files for context:
- CLAUDE.md (project overview)
- .cursor/rules/guardrail-sim.mdc (detailed conventions)
- docs/ARCHITECTURE.md (technical decisions)
```

## Building Agent-Aware Features

### Structured Responses

All MCP tools return structured JSON that agents can parse:

```json
{
  "approved": false,
  "violations": [
    {
      "rule": "volume_tier",
      "message": "Orders under 100 units limited to 10% discount",
      "limit": 0.1
    }
  ],
  "applied_rules": ["margin_floor", "max_discount", "volume_tier"]
}
```

### Actionable Suggestions

Tools provide context for next actions:

```json
{
  "max_discount": 0.1,
  "limiting_factor": "volume_tier",
  "details": "Base tier (< 100 units) limited to 10% discount"
}
```

An agent can use this to suggest: "Increase quantity to 100+ for higher discount."

## MCP Best Practices

When building agents that use Guardrail-Sim:

### 1. Always Validate Before Committing

```typescript
// ❌ Don't commit discounts without checking
await commitDiscount(order, 0.2);

// ✅ Validate first
const result = await mcp.callTool({
  name: 'evaluate_policy',
  arguments: { order, proposed_discount: 0.2 },
});

if (result.approved) {
  await commitDiscount(order, 0.2);
} else {
  // Handle rejection
}
```

### 2. Use get_max_discount for Negotiation Ceiling

```typescript
// Know your limits before negotiating
const maxResult = await mcp.callTool({
  name: 'get_max_discount',
  arguments: { order },
});

// Now you know the ceiling
console.log(`Can offer up to ${maxResult.max_discount_pct}`);
```

### 3. Explain Rejections Clearly

```typescript
if (!result.approved) {
  for (const violation of result.violations) {
    // Provide actionable feedback
    console.log(`${violation.rule}: ${violation.message}`);
  }
}
```

## Testing Agent Integration

Use the InMemoryTransport for testing without a real server:

```typescript
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { InMemoryTransport } from '@modelcontextprotocol/sdk/inMemory.js';
import { createServer } from '@guardrail-sim/mcp-server';

const server = createServer();
const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();
const client = new Client({ name: 'test', version: '1.0.0' }, { capabilities: {} });

await Promise.all([client.connect(clientTransport), server.connect(serverTransport)]);

// Now test tool calls
const result = await client.callTool({
  name: 'evaluate_policy',
  arguments: { order, proposed_discount: 0.12 },
});
```
